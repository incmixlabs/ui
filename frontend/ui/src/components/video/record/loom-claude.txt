I'll help you create a basic Loom-like screen recording application using React, Shadcn UI, and TypeScript. This example will include the main recording functionality and a simple interface.

tsx// src/components/ScreenRecorder.tsx

import React, { useState, useRef } from 'react';
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Video, Mic, Camera, StopCircle } from "lucide-react";
import { toast } from "@/components/ui/use-toast";

interface RecordingOptions {
  audio: boolean;
  video: boolean;
  screen: boolean;
}

const ScreenRecorder: React.FC = () => {
  // State management for recording status and options
  const [isRecording, setIsRecording] = useState<boolean>(false);
  const [recordingOptions, setRecordingOptions] = useState<RecordingOptions>({
    audio: true,
    video: true,
    screen: true,
  });

  // Refs for managing media recorder and streams
  const mediaRecorder = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const chunksRef = useRef<Blob[]>([]);

  // Handle starting the recording
  const startRecording = async () => {
    try {
      const streams: MediaStream[] = [];

      // Get screen capture if enabled
      if (recordingOptions.screen) {
        const screenStream = await navigator.mediaDevices.getDisplayMedia({
          video: true,
        });
        streams.push(screenStream);
      }

      // Get camera and audio if enabled
      if (recordingOptions.video || recordingOptions.audio) {
        const userStream = await navigator.mediaDevices.getUserMedia({
          video: recordingOptions.video,
          audio: recordingOptions.audio,
        });
        streams.push(userStream);
      }

      // Combine all streams
      const combinedStream = new MediaStream();
      streams.forEach(stream => {
        stream.getTracks().forEach(track => {
          combinedStream.addTrack(track);
        });
      });

      streamRef.current = combinedStream;

      // Create and configure MediaRecorder
      const recorder = new MediaRecorder(combinedStream, {
        mimeType: 'video/webm',
      });

      recorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };

      recorder.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        downloadRecording(url);
        chunksRef.current = [];
      };

      mediaRecorder.current = recorder;
      recorder.start();
      setIsRecording(true);
      toast({
        title: "Recording started",
        description: "Your screen recording has begun.",
      });
    } catch (error) {
      console.error('Error starting recording:', error);
      toast({
        title: "Error",
        description: "Failed to start recording.",
        variant: "destructive",
      });
    }
  };

  // Handle stopping the recording
  const stopRecording = () => {
    if (mediaRecorder.current && streamRef.current) {
      mediaRecorder.current.stop();
      streamRef.current.getTracks().forEach(track => track.stop());
      setIsRecording(false);
      toast({
        title: "Recording stopped",
        description: "Your recording has been saved.",
      });
    }
  };

  // Handle downloading the recording
  const downloadRecording = (url: string) => {
    const a = document.createElement('a');
    a.href = url;
    a.download = `recording-${new Date().toISOString()}.webm`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  // Toggle recording options
  const toggleOption = (option: keyof RecordingOptions) => {
    setRecordingOptions(prev => ({
      ...prev,
      [option]: !prev[option],
    }));
  };

  return (
    <Card className="w-[400px] mx-auto mt-10">
      <CardContent className="p-6">
        <div className="space-y-4">
          <div className="flex gap-2 justify-center">
            <Button
              variant={recordingOptions.audio ? "default" : "outline"}
              onClick={() => toggleOption('audio')}
              disabled={isRecording}
            >
              <Mic className="w-4 h-4 mr-2" />
              Audio
            </Button>
            <Button
              variant={recordingOptions.video ? "default" : "outline"}
              onClick={() => toggleOption('video')}
              disabled={isRecording}
            >
              <Camera className="w-4 h-4 mr-2" />
              Camera
            </Button>
            <Button
              variant={recordingOptions.screen ? "default" : "outline"}
              onClick={() => toggleOption('screen')}
              disabled={isRecording}
            >
              <Video className="w-4 h-4 mr-2" />
              Screen
            </Button>
          </div>

          <Button
            className="w-full"
            variant={isRecording ? "destructive" : "default"}
            onClick={isRecording ? stopRecording : startRecording}
          >
            {isRecording ? (
              <>
                <StopCircle className="w-4 h-4 mr-2" />
                Stop Recording
              </>
            ) : (
              <>
                <Video className="w-4 h-4 mr-2" />
                Start Recording
              </>
            )}
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default ScreenRecorder;

To use this component, you'll need to have the following dependencies installed:

bashnpm install @radix-ui/react-toast lucide-react @shadcn/ui

And make sure to set up your tailwind.config.js and necessary Shadcn UI components.

This code provides:

Screen recording functionality
Webcam recording
Audio recording
Options to toggle different recording sources
Download functionality for the recorded video
Toast notifications for user feedback
A clean UI using Shadcn components

To use this component in your application:

tsx// src/App.tsx
import ScreenRecorder from './components/ScreenRecorder';
import { Toaster } from "@/components/ui/toaster";

function App() {
  return (
    <div>
      <ScreenRecorder />
      <Toaster />
    </div>
  );
}

export default App;

This implementation provides a basic Loom-like experience. You might want to add additional features like:

Preview window for the recording
Recording timer
Different video quality options
Cloud upload functionality
Video trimming capabilities

Remember to handle proper error cases and browser compatibility issues in a production environment.

Mar 27 2025, 15:19:35

O3-Mini medium

Below is an example of a simple Loom-inspired video recorder built using React, Shadcn UI components, and TypeScript. In this sample, we create a component that accesses the webcam, allows the user to start/stop recording using the MediaRecorder API, and then provides a preview of the recorded video. You can expand on this skeleton to add features like screen recording, file saving, or advanced UI interactions.

Assumptions:
• You have installed and set up React with TypeScript.
• You have integrated Shadcn UI (or a similar design system based on Tailwind CSS) in your project. For example, the Button component is imported from “@/components/ui/button.”
• This sample is self-contained in one file (e.g., App.tsx), but you can refactor it into separate components as needed.

Below is the complete code snippet with detailed comments:

/* App.tsx */
import React, { useState, useRef, useEffect } from "react";
// Importing a Button component from the Shadcn UI library
import { Button } from "@/components/ui/button"; // Adjust the path as needed

// Define the VideoRecorder component
const VideoRecorder: React.FC = () => {
// Ref for the video element that shows the live stream
const videoPreviewRef = useRef(null);
// Ref for the MediaRecorder instance
const mediaRecorderRef = useRef<MediaRecorder | null>(null);

// State to hold the recorded video URL once recording stops
const [recordedVideoURL, setRecordedVideoURL] = useState("");
// State to know if we are currently recording or not
const [isRecording, setIsRecording] = useState(false);
// Temp array to store the recorded data chunks
const [recordedChunks, setRecordedChunks] = useState<Blob[]>([]);

// Function to start capturing the webcam media and record it
const startRecording = async () => {
// Request permissions for video (and/or audio as needed)
try {
const stream = await navigator.mediaDevices.getUserMedia({
video: true,
audio: true,
});
// Set the stream as the source for the video element for live preview
if (videoPreviewRef.current) {
videoPreviewRef.current.srcObject = stream;
videoPreviewRef.current.play();
}
// Create a new MediaRecorder instance for the stream
const options = { mimeType: "video/webm; codecs=vp9" }; // Adjust codecs if necessary
const mediaRecorder = new MediaRecorder(stream, options);
mediaRecorderRef.current = mediaRecorder;
setRecordedChunks([]); // Clear any previous recordings

// Event handler for when data is available from the recorder
  mediaRecorder.ondataavailable = (event: BlobEvent) => {
    if (event.data.size > 0) {
      setRecordedChunks((prevChunks) => [...prevChunks, event.data]);
    }
  };

  // When recording stops, convert the blob chunks into a video URL for preview
  mediaRecorder.onstop = () => {
    const blob = new Blob(recordedChunks, {
      type: "video/webm",
    });
    const url = window.URL.createObjectURL(blob);
    setRecordedVideoURL(url);
    // Stop all tracks of the stream to free up the webcam
    if (videoPreviewRef.current && videoPreviewRef.current.srcObject) {
      const stream = videoPreviewRef.current.srcObject as MediaStream;
      stream.getTracks().forEach((track) => track.stop());
      videoPreviewRef.current.srcObject = null;
    }
  };

  // Start recording and update the UI state
  mediaRecorder.start();
  setIsRecording(true);
} catch (err) {
  console.error("Error accessing user media:", err);
}

};

// Function to stop the recording process
const stopRecording = () => {
if (mediaRecorderRef.current && isRecording) {
mediaRecorderRef.current.stop();
setIsRecording(false);
}
};

// Clean up the video URL when the component unmounts
useEffect(() => {
return () => {
if (recordedVideoURL) {
window.URL.revokeObjectURL(recordedVideoURL);
}
};
}, [recordedVideoURL]);

return (

Loom-Like Video Recorder

{/* Video element displaying live preview or recorded video */}
  <div className="w-full max-w-lg border rounded-md shadow-md">
    {isRecording ? (
      <video ref={videoPreviewRef} className="w-full" />
    ) : recordedVideoURL ? (
      <video src={recordedVideoURL} controls className="w-full" />
    ) : (
      <div className="p-6 text-center text-gray-500">
        Video preview will appear here...
      </div>
    )}
  </div>

  {/* Control buttons to start or stop recording */}
  <div className="flex gap-4">
    <Button onClick={startRecording} disabled={isRecording}>
      Start Recording
    </Button>
    <Button onClick={stopRecording} disabled={!isRecording}>
      Stop Recording
    </Button>
  </div>
</div>

);
};

// Main App component rendering the VideoRecorder
const App: React.FC = () => {
return (

);
};

export default App;

Explanation:

The VideoRecorder component leverages the MediaRecorder API to capture webcam and microphone input. It stores video chunks in an array and then creates a Blob URL to preview the video once recording stops.
Shadcn UI’s Button component is used to provide a consistent design. You can replace it with your custom button components if needed.
The video element shows either a live preview (while recording) or a recorded video once the recording is stopped.
Basic error handling is implemented to catch any issues during getUserMedia access.

You can run this code in your React project (after ensuring that the necessary dependencies are installed) to test the Loom-like recording feature. From here, you might want to refine the UI, add additional settings (like choosing webcam or microphone), or integrate further with backend services.

Mar 27 2025, 15:19:35

    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
