Project Structure

loom-clone/
├── public/
│   ├── manifest.json
│   └── icons/
├── src/
│   ├── popup/
│   ├── background/
│   ├── content/
│   └── components/
├── package.json
└── vite.config.ts

1. Manifest File (public/manifest.json)

json{
  "manifest_version": 3,
  "name": "Loom Clone",
  "version": "1.0.0",
  "description": "A Loom-like screen and camera recording extension",
  "permissions": [
    "desktopCapture",
    "tabCapture",
    "activeTab",
    "storage",
    "downloads",
    "audioCapture"
  ],
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icons/icon16.png",
      "48": "icons/icon48.png",
      "128": "icons/icon128.png"
    }
  },
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  },
  "web_accessible_resources": [
    {
      "resources": ["assets/*"],
      "matches": ["<all_urls>"]
    }
  ]
}

2. Recording Service (src/lib/recordingService.ts)

typescript// src/lib/recordingService.ts

/**
 * This service handles all recording functionalities for the extension
 * It manages screen capture, camera capture, and audio recording
 */
export interface RecordingOptions {
  audio: boolean;       // Whether to record audio
  camera: boolean;      // Whether to include camera
  screen: boolean;      // Whether to record screen
  quality: 'high' | 'medium' | 'low'; // Recording quality
  showCameraPreview: boolean; // Whether to show camera preview
}

// Quality presets for different recording modes
const QUALITY_PRESETS = {
  high: { width: 1920, height: 1080, frameRate: 30 },
  medium: { width: 1280, height: 720, frameRate: 30 },
  low: { width: 854, height: 480, frameRate: 24 },
};

class RecordingService {
  private mediaRecorder: MediaRecorder | null = null;
  private recordedChunks: Blob[] = [];
  private screenStream: MediaStream | null = null;
  private cameraStream: MediaStream | null = null;
  private audioStream: MediaStream | null = null;
  private combinedStream: MediaStream | null = null;
  private recordingStartTime: number = 0;
  private isRecording: boolean = false;

  /**
   * Start a new recording session with the provided options
   */
  async startRecording(options: RecordingOptions): Promise<boolean> {
    try {
      // Reset state
      this.recordedChunks = [];

      // Get screen capture if enabled
      if (options.screen) {
        this.screenStream = await this.captureScreen(options.quality);
      }

      // Get camera if enabled
      if (options.camera) {
        this.cameraStream = await this.captureCamera(options.quality);
      }

      // Get audio if enabled
      if (options.audio) {
        this.audioStream = await this.captureAudio();
      }

      // Combine all streams
      this.combinedStream = this.createCombinedStream();

      if (!this.combinedStream || this.combinedStream.getTracks().length === 0) {
        throw new Error("No media to record");
      }

      // Create and configure MediaRecorder
      this.mediaRecorder = new MediaRecorder(this.combinedStream, {
        mimeType: 'video/webm;codecs=vp9',
      });

      // Handle data chunks as they become available
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      // Start recording
      this.mediaRecorder.start(1000); // Collect data every second
      this.isRecording = true;
      this.recordingStartTime = Date.now();

      // Notify content script that recording has started
      this.notifyRecordingStatus(true);

      return true;
    } catch (error) {
      console.error("Error starting recording:", error);
      this.cleanupStreams();
      return false;
    }
  }

  /**
   * Stop the current recording and save the video
   */
  async stopRecording(): Promise<string | null> {
    return new Promise((resolve, reject) => {
      if (!this.mediaRecorder || this.mediaRecorder.state === 'inactive') {
        this.cleanupStreams();
        resolve(null);
        return;
      }

      // Handle recording completion
      this.mediaRecorder.onstop = () => {
        // Create final video blob from all recorded chunks
        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);

        // Save the recording
        chrome.downloads.download({
          url: url,
          filename: `loom-recording-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`,
          saveAs: true
        });

        this.isRecording = false;
        this.cleanupStreams();
        this.notifyRecordingStatus(false);

        resolve(url);
      };

      this.mediaRecorder.stop();
    });
  }

  /**
   * Get current recording status and duration
   */
  getRecordingStatus(): { isRecording: boolean, duration: number } {
    return {
      isRecording: this.isRecording,
      duration: this.isRecording ? Math.floor((Date.now() - this.recordingStartTime) / 1000) : 0
    };
  }

  /**
   * Capture screen using Chrome's desktopCapture API
   */
  private captureScreen(quality: 'high' | 'medium' | 'low'): Promise<MediaStream> {
    return new Promise((resolve, reject) => {
      // Using Chrome's desktop capture API
      chrome.desktopCapture.chooseDesktopMedia(
        ['screen', 'window', 'tab'],
        (streamId) => {
          if (!streamId) {
            reject(new Error("Screen capture permission denied"));
            return;
          }

          const constraints = {
            audio: false,
            video: {
              mandatory: {
                chromeMediaSource: 'desktop',
                chromeMediaSourceId: streamId,
                maxWidth: QUALITY_PRESETS[quality].width,
                maxHeight: QUALITY_PRESETS[quality].height,
                frameRate: QUALITY_PRESETS[quality].frameRate
              }
            }
          };

          navigator.mediaDevices.getUserMedia(constraints as MediaStreamConstraints)
            .then(resolve)
            .catch(reject);
        }
      );
    });
  }

  /**
   * Capture camera video
   */
  private async captureCamera(quality: 'high' | 'medium' | 'low'): Promise<MediaStream> {
    try {
      return await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: QUALITY_PRESETS[quality].width },
          height: { ideal: QUALITY_PRESETS[quality].height },
          frameRate: { ideal: QUALITY_PRESETS[quality].frameRate }
        },
        audio: false
      });
    } catch (error) {
      console.error("Camera capture error:", error);
      throw error;
    }
  }

  /**
   * Capture audio from microphone
   */
  private async captureAudio(): Promise<MediaStream> {
    try {
      return await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true
        },
        video: false
      });
    } catch (error) {
      console.error("Audio capture error:", error);
      throw error;
    }
  }

  /**
   * Create a combined stream from all active media streams
   */
  private createCombinedStream(): MediaStream {
    const combinedStream = new MediaStream();

    // Add all tracks from all streams
    [this.screenStream, this.cameraStream, this.audioStream]
      .filter(stream => stream !== null)
      .forEach(stream => {
        stream!.getTracks().forEach(track => {
          combinedStream.addTrack(track);
        });
      });

    return combinedStream;
  }

  /**
   * Clean up all media streams
   */
  private cleanupStreams(): void {
    // Stop all tracks in all streams
    [this.screenStream, this.cameraStream, this.audioStream, this.combinedStream]
      .filter(stream => stream !== null)
      .forEach(stream => {
        stream!.getTracks().forEach(track => track.stop());
      });

    this.screenStream = null;
    this.cameraStream = null;
    this.audioStream = null;
    this.combinedStream = null;
    this.mediaRecorder = null;
  }

  /**
   * Notify content script about recording status changes
   */
  private notifyRecordingStatus(isRecording: boolean): void {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      const activeTab = tabs[0];
      if (activeTab && activeTab.id) {
        chrome.tabs.sendMessage(activeTab.id, {
          action: isRecording ? 'RECORDING_STARTED' : 'RECORDING_STOPPED'
        });
      }
    });
  }
}

// Export a singleton instance
export default new RecordingService();

3. Popup Component (src/popup/Popup.tsx)

tsx// src/popup/Popup.tsx

import React, { useState, useEffect } from 'react';
import { createRoot } from 'react-dom/client';
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, Tabs.Content, TabsList, Tabs.Trigger } from "@/components/ui/tabs";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Video, Mic, Camera, StopCircle, Settings } from "lucide-react";
import { useToast } from "@/components/ui/use-toast";
import { Toaster } from "@/components/ui/toaster";
import { RecordingOptions } from '@/lib/recordingService';
import '../styles/globals.css';

/**
 * Main popup component for the extension
 * Handles the UI for starting/stopping recordings and configuring options
 */
const Popup: React.FC = () => {
  // State for recording options and status
  const [options, setOptions] = useState<RecordingOptions>({
    audio: true,
    camera: true,
    screen: true,
    quality: 'high',
    showCameraPreview: true
  });

  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const { toast } = useToast();

  // Load saved options when popup opens
  useEffect(() => {
    chrome.storage.sync.get(['recordingOptions'], (result) => {
      if (result.recordingOptions) {
        setOptions(result.recordingOptions);
      }
    });

    // Check if recording is in progress
    chrome.runtime.sendMessage({ action: 'GET_RECORDING_STATUS' }, (response) => {
      if (response) {
        setIsRecording(response.isRecording);
        setRecordingTime(response.duration);
      }
    });
  }, []);

  // Save options when they change
  useEffect(() => {
    chrome.storage.sync.set({ recordingOptions: options });
  }, [options]);

  // Setup recording time counter
  useEffect(() => {
    let interval: number | undefined;

    if (isRecording) {
      interval = window.setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isRecording]);

  /**
   * Start a new recording with current options
   */
  const startRecording = () => {
    chrome.runtime.sendMessage(
      { action: 'START_RECORDING', options },
      (response) => {
        if (response && response.success) {
          setIsRecording(true);
          setRecordingTime(0);
          toast({
            title: "Recording started",
            description: "Your screen recording has begun",
          });
        } else {
          toast({
            title: "Recording failed",
            description: response?.error || "An unknown error occurred",
            variant: "destructive",
          });
        }
      }
    );
  };

  /**
   * Stop the current recording
   */
  const stopRecording = () => {
    chrome.runtime.sendMessage(
      { action: 'STOP_RECORDING' },
      (response) => {
        if (response && response.success) {
          setIsRecording(false);
          toast({
            title: "Recording saved",
            description: "Your recording has been saved successfully",
          });
        } else {
          toast({
            title: "Error stopping recording",
            description: response?.error || "An unknown error occurred",
            variant: "destructive",
          });
        }
      }
    );
  };

  // Format seconds to mm:ss display
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="w-[360px]">
      <Card className="border-0">
        <CardHeader className="pb-2">
          <CardTitle className="text-xl flex items-center gap-2">
            <Video className="w-5 h-5" />
            Loom Clone
          </CardTitle>
        </CardHeader>

        <CardContent>
          <Tabs.root defaultValue="record" className="w-full">
            <Tabs.list  className="grid grid-cols-2 mb-4">
              <Tabs.Trigger value="record">Record</Tabs.Trigger>
              <Tabs.Trigger value="settings">Settings</Tabs.Trigger>
            </TabsList>

            {/* Recording Tab */}
            <Tabs.Content value="record" className="space-y-4">
              <div className="flex justify-between">
                <div className="flex flex-col items-center">
                  <Button
                    size="sm"
                    variant={options.screen ? "default" : "outline"}
                    onClick={() => !isRecording && setOptions(prev => ({ ...prev, screen: !prev.screen }))}
                    disabled={isRecording}
                    className="h-14 w-14 rounded-full p-0"
                  >
                    <Video className="h-6 w-6" />
                  </Button>
                  <Label className="mt-2">Screen</Label>
                </div>

                <div className="flex flex-col items-center">
                  <Button
                    size="sm"
                    variant={options.camera ? "default" : "outline"}
                    onClick={() => !isRecording && setOptions(prev => ({ ...prev, camera: !prev.camera }))}
                    disabled={isRecording}
                    className="h-14 w-14 rounded-full p-0"
                  >
                    <Camera className="h-6 w-6" />
                  </Button>
                  <Label className="mt-2">Camera</Label>
                </div>

                <div className="flex flex-col items-center">
                  <Button
                    size="sm"
                    variant={options.audio ? "default" : "outline"}
                    onClick={() => !isRecording && setOptions(prev => ({ ...prev, audio: !prev.audio }))}
                    disabled={isRecording}
                    className="h-14 w-14 rounded-full p-0"
                  >
                    <Mic className="h-6 w-6" />
                  </Button>
                  <Label className="mt-2">Audio</Label>
                </div>
              </div>

              {/* Recording timer */}
              {isRecording && (
                <div className="flex items-center justify-center py-2 text-xl font-semibold text-red-500">
                  <div className="w-3 h-3 rounded-full bg-red-500 animate-pulse mr-2"></div>
                  {formatTime(recordingTime)}
                </div>
              )}

              {/* Main action button */}
              <Button
                className="w-full"
                size="lg"
                variant={isRecording ? "destructive" : "default"}
                onClick={isRecording ? stopRecording : startRecording}
              >
                {isRecording ? (
                  <>
                    <StopCircle className="mr-2 h-5 w-5" />
                    Stop Recording
                  </>
                ) : (
                  <>
                    <Video className="mr-2 h-5 w-5" />
                    Start Recording
                  </>
                )}
              </Button>
            </Tabs.Content>

            {/* Settings Tab */}
            <Tabs.Content value="settings" className="space-y-4">
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="quality">Recording Quality</Label>
                  <Select
                    value={options.quality}
                    onValueChange={(value: 'high' | 'medium' | 'low') =>
                      setOptions(prev => ({ ...prev, quality: value }))
                    }
                    disabled={isRecording}
                  >
                    <SelectTrigger id="quality">
                      <SelectValue placeholder="Select quality" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="high">High (1080p)</SelectItem>
                      <SelectItem value="medium">Medium (720p)</SelectItem>
                      <SelectItem value="low">Low (480p)</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="flex items-center justify-between">
                  <Label htmlFor="camera-preview">Show Camera Preview</Label>
                  <Switch
                    id="camera-preview"
                    checked={options.showCameraPreview}
                    onCheckedChange={(checked) =>
                      setOptions(prev => ({ ...prev, showCameraPreview: checked }))
                    }
                    disabled={isRecording}
                  />
                </div>
              </div>
            </Tabs.Content>
          </Tabs>
        </CardContent>
      </Card>
      <Toaster />
    </div>
  );
};

// Mount the React component
const container = document.getElementById('root');
if (container) {
  const root = createRoot(container);
  root.render(<Popup />);
}

export default Popup;

4. Background Script (src/background/background.ts)

typescript// src/background/background.ts

import recordingService from '../lib/recordingService';

/**
 * Background script for the Chrome extension
 * Handles communication between popup and content scripts
 */

// Handle extension installation
chrome.runtime.onInstalled.addListener((details) => {
  if (details.reason === 'install') {
    console.log('Loom Clone Extension installed');

    // Initialize default settings
    chrome.storage.sync.set({
      recordingOptions: {
        audio: true,
        camera: true,
        screen: true,
        quality: 'high',
        showCameraPreview: true
      }
    });
  }
});

// Message handler
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('Background received message:', message.action);

  switch (message.action) {
    case 'START_RECORDING':
      // Start a new recording with the provided options
      recordingService.startRecording(message.options)
        .then(success => {
          sendResponse({ success });
        })
        .catch(error => {
          console.error('Error starting recording:', error);
          sendResponse({ success: false, error: error.message });
        });
      return true; // Indicates async response

    case 'STOP_RECORDING':
      // Stop the current recording
      recordingService.stopRecording()
        .then(url => {
          sendResponse({ success: true, url });
        })
        .catch(error => {
          console.error('Error stopping recording:', error);
          sendResponse({ success: false, error: error.message });
        });
      return true; // Indicates async response

    case 'GET_RECORDING_STATUS':
      // Get current recording status
      const status = recordingService.getRecordingStatus();
      sendResponse(status);
      return false; // Synchronous response
  }
});

// Keep service worker alive
console.log('Loom Clone background service worker initialized');

5. Content Script (src/content/content.tsx)

tsx// src/content/content.tsx

import React, { useState, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';
import { Mic, Camera, Video, Timer } from 'lucide-react';
import '../styles/globals.css';

/**
 * Component for displaying recording controls and status
 * This is injected into the active page when recording
 */
const RecordingControls: React.FC = () => {
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [showControls, setShowControls] = useState(true);
  const controlsRef = useRef<HTMLDivElement>(null);

  // Setup message listener
  useEffect(() => {
    const messageHandler = (message: any) => {
      if (message.action === 'RECORDING_STARTED') {
        setIsRecording(true);
        setRecordingTime(0);
        setShowControls(true);
      } else if (message.action === 'RECORDING_STOPPED') {
        setIsRecording(false);
      }
    };

    // Register message listener
    chrome.runtime.onMessage.addListener(messageHandler);

    // Check if already recording
    chrome.runtime.sendMessage({ action: 'GET_RECORDING_STATUS' }, (response) => {
      if (response && response.isRecording) {
        setIsRecording(true);
        setRecordingTime(response.duration);
      }
    });

    // Cleanup on unmount
    return () => {
      chrome.runtime.onMessage.removeListener(messageHandler);
    };
  }, []);

  // Setup recording timer
  useEffect(() => {
    let interval: number | undefined;

    if (isRecording) {
      interval = window.setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [isRecording]);

  // Format seconds to mm:ss
  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  // Make controls draggable
  useEffect(() => {
    if (!controlsRef.current) return;

    let isDragging = false;
    let offsetX: number, offsetY: number;

    const handleMouseDown = (e: MouseEvent) => {
      isDragging = true;
      offsetX = e.clientX - controlsRef.current!.getBoundingClientRect().left;
      offsetY = e.clientY - controlsRef.current!.getBoundingClientRect().top;
    };

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;

      const left = e.clientX - offsetX;
      const top = e.clientY - offsetY;

      controlsRef.current!.style.left = `${left}px`;
      controlsRef.current!.style.top = `${top}px`;
    };

    const handleMouseUp = () => {
      isDragging = false;
    };

    controlsRef.current.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      controlsRef.current?.removeEventListener('mousedown', handleMouseDown);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [controlsRef.current]);

  if (!isRecording) return null;

  return (
    <div
      ref={controlsRef}
      className={`fixed bottom-4 left-4 z-[9999] ${showControls ? 'opacity-100' : 'opacity-20'} hover:opacity-100 transition-opacity`}
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      <div className="flex items-center bg-black bg-opacity-80 text-white py-2 px-4 rounded-full shadow-lg cursor-move">
        <div className="flex items-center mr-3">
          <div className="w-3 h-3 rounded-full bg-red-500 animate-pulse mr-2"></div>
          <span className="font-medium">REC</span>
        </div>

        <div className="h-4 w-[1px] bg-gray-500 mx-2"></div>

        <div className="flex items-center">
          <Timer className="w-4 h-4 mr-1" />
          <span>{formatTime(recordingTime)}</span>
        </div>
      </div>
    </div>
  );
};

// Create container and inject component
const container = document.createElement('div');
container.id = 'loom-clone-container';
document.body.appendChild(container);

const root = createRoot(container);
root.render(<RecordingControls />);

6. Setup Instructions

Package.json Configuration:

json{
  "name": "loom-clone-extension",
  "version": "1.0.0",
  "description": "A Chrome extension that mimics Loom functionality",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@radix-ui/react-dialog": "^1.0.4",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^1.2.2",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-switch": "^1.0.3",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.4",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "lucide-react": "^0.258.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tailwind-merge": "^1.14.0"
  },
  "devDependencies": {
    "@types/chrome": "^0.0.243",
    "@types/node": "^20.4.5",
    "@types/react": "^18.2.18",
    "@types/react-dom": "^18.2.7",
    "@vitejs/plugin-react": "^4.0.4",
    "autoprefixer": "^10.4.14",
    "postcss": "^8.4.27",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.1.6",
    "vite": "^4.4.8"
  }
}

Vite Configuration (vite.config.ts):

typescriptimport { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    rollupOptions: {
      input: {
        popup: resolve(__dirname, 'src/popup/index.html'),
        background: resolve(__dirname, 'src/background/background.ts'),
        content: resolve(__dirname, 'src/content/content.tsx')
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: 'assets/[name].[hash].js',
        assetFileNames: 'assets/[name].[hash].[ext]'
      }
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
});

Installation Instructions

Clone or create the project with the files above
Run npm install to install dependencies
Install the shadcn components you need:

bashnpx shadcn-ui@latest init
npx shadcn-ui@latest add button card tabs switch label select toast

Build the extension:

bashnpm run build

Load the extension in Chrome:

Open Chrome and go to chrome://extensions/
Enable "Developer mode" in the top right
Click "Load unpacked" and select the dist folder from your project

Features Implemented

Screen recording with quality options
Camera recording
Audio recording
Recording controls overlay
Draggable recording status indicator
Timer showing recording duration
Settings management
Toast notifications for user feedback

This implementation provides a comprehensive Loom-like experience directly in your browser as a Chrome extension. The code is structured to be maintainable and follows modern React patterns with TypeScript for type safety.
